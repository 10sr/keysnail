#hoge ; -*- mode: Muse; coding: euc-jp-unix -*-
#created 2009-07-25 13:54
#author mooz
#title KeySnail How to
#desc あんなことやこんなことはどうすればできるの？

<contents>

* キーバインド
** モードとは
** キーマップとは
** 関数をキーへ割り当てるには
** 関数を複数のキーシーケンスへ一気に割り当てたい
* キーの設定
** 特殊キーの設定
** コントロール / メタキーの変更

h1. キーバインド

h2. モードとは

この拡張機能では、現在の状態を次のように区別し、モードと呼びます。

| View mode  | カーソルが表示されていない、通常のブラウジングモード                               |
| Caret mode | F7 キーを入力することで入れる、カーソルが表示されたキャレットブラウジングモード    |
| Edit mode  | テキストボックスやインプットエリアなどにカーソルがあり、テキストを編集している状態 |

h2. キーマップとは

「キーの組み合わせ」と「関数(機能)」の対応を定義したものです。 例えば「Ctrl + a」に対して「行頭へ移動」を対応付ける、といった具合です。

上で示したそれぞれのモードには「どんなキーの組み合わせ」が「どんな機能」に割り当てられているかが設定された「ローカルキーマップ」というものが用意されています。

また、それぞれのモードの上位へ位置するものとして「グローバルキーマップ」というものも用意されています。

この拡張機能はユーザが入力したキーの組み合わせを、以下のような順番で探します。

# 現在のモードに対応するローカルキーマップ
# (1. で見つからなければ)グローバルキーマップ

「それぞれのモード特有のキーバインドを定義したければローカルキーマップ、それ以外はグローバルキーマップ」というスタンスでキーの割り当てを行っていくのが良いでしょう。

h2. 関数をキーへ割り当てるには

この拡張機能では各モードに対し「キーの組み合わせ」と「呼び出される機能」を割り当てることが可能です。これは設定ファイル内に、次のような記述をすることで行います。

<script src="http://gist.github.com/160278.js"></script>

各関数の定義は次のようになっており、全く同じ引数を取ることが分かります。

<pre>
<code>
key.setEditKey(keys, func, ksDescription, ksNoRepeat);
key.setViewKey(keys, func, ksDescription, ksNoRepeat);
key.setCaretKey(keys, func, ksDescription, ksNoRepeat);
key.setGlobalKey(keys, func, ksDescription, ksNoRepeat);
</code>
</pre>

各引数の説明は以下の通りです。

|_.引数名          |_. 説明                                                       |
| keys          | キー (文字列) か キーシーケンス (文字列の配列) を指定する    |
| func          | キー入力があった場合に呼び出したい無名関数を指定する         |
| ksDescription | 関数の説明                                                   |
| ksNoRepeat    | 前置引数が与えられたときコマンドの繰り返しを抑制するかどうか |

h2. はじめてのキーバインド定義

では、ここで試しに次のようなコードを設定ファイルに記述してみましょう。

<script src="http://gist.github.com/160282.js"></script>

ファイルを保存したら、ステータスバーのメニューから設定ファイルを再読み込みさせます。

設定ファイルは読み込まれましたか？　そうしたら Ctrl + c, Ctrl + w, Ctrl + a と順番に打ち込んでみましょう。間違えた場合は Ctrl + g でキャンセルして初めからやり直しが出来ます。

どうですか、うまくいけば次のようなダイアログが表示されるはずです。

[[./images/screenshot2.png][hello dialog]]

h2. 前置引数を使う

Emacs ユーザの方は、前置引数をご存知かと思います。通常のキーシーケンスを打ち込む前に、 C-u や C-- の後に続けて数字を入力しておくと、その数字がコマンドへ渡される、というものです。

この拡張機能でも同様にして、前置引数を使うことが出来ます。先程の設定を次のように変更してみてください。

<script src="http://gist.github.com/160283.js"></script>

そして先程のようにして Ctrl + c, Ctrl + w, Ctrl + a と順に打ち込みます。すると次のようなダイアログが表示されることでしょう。

[[./images/screenshot3.png][hello dialog with no prefix argument]]

前置引数の入力を行わずに関数を呼び出したので、 null となっていますね。では次に C-u 3 と入力してから C-c C-w C-a と続けてみてください。ダイアログの表記が次のように変わるはずです。

[[./images/screenshot4.png][hello dialog with prefix argument 3]]

前置引数として 3 を指定したので、その値がしっかり表示されていますね。

それでは、ダイアログを閉じてみてください。すると、ダイアログを閉じたにも関わらず、先程と同じダイアログが現れました。もう一度ダイアログを閉じます。また、同じダイアログが現れます。ダイアログを閉じます……安心して下さい。これで終わりです。

どうしてこんなことが起こったのでしょう。少し戻って、何度ダイアログが開いたかを数えてみてください。　3 回ですね。そう、これは前置引数の値と一致します。言い換えれば、「前置引数で指定した数だけ、コマンドが繰り返された」ということになります。

前置引数が与えられたとき、特に指定がなければこの拡張機能はコマンドを前置引数の回数分繰り返し実行します。例えばテキストエリアで C-u 20 * と入力してみてください。 ******************* という具合に、 * が 20 個入力されるのが確認出来ることでしょう。

しかし、今回のように「コマンドを繰り返してほしくない」場合も多々あります。そんなときは関数説明の後、つまりキーバインド定義関数の第四引数へ true を指定して下さい。先程の例だと次のようになります。

<script src="http://gist.github.com/160284.js"></script>

設定ファイルを保存して、再読み込みしてから C-u 3 C-c C-w C-a と入力してみましょう。先程同様にダイアログが表示されますね。では、ダイアログを閉じて見てください。もうダイアログは復活しません。一度だけの実行となったのです。

h2. 関数を複数のキーシーケンスへ一気に割り当てたい

ある関数を、複数のキーシーケンスへ割り当てたい、ということは結構あります。

例えば "g" と "M-<" そして ["ESC", "<"] に対して「ページ先頭へ移動」という関数を割り当てたい、と思ったとき

<script src="http://gist.github.com/160285.js"></script>

として同じような呼び出しを何度も行うのでは、どうにも無駄が多い感じがします。

こんなときの為に、各 set*Key() には特別なフォームが用意されています。次のコードをご覧下さい。

<script src="http://gist.github.com/160288.js"></script>

このコードでは先程の例と同様の割り当てを行っていますが、ずいぶんすっきりとしました。違うのは、

# setViewKey() を一度しか呼んでいない
# setViewKey() 第一引数が「配列の配列」になっている

ということです。

各 set*Key() は通常「文字列」もしくは「文字列の配列」を第一引数にとり、そこで指定されたキーの組み合わせに関数を割り当てます。しかし「文字列の配列の配列」が指定された場合は、各文字列の配列に対して一つずつ関数を割り当てるようになるのです。

複数のキーシーケンスに対してある関数を一度に割り当てたいときは「配列の配列」を指定する、ということを覚えておけば良いでしょう。

h1. キーの設定

h2. 特殊キーの設定

特殊キーとは、次に示すキーのことを言います。

|_. キー名      |_. 役割                                     |_. デフォルト値 |
| quitKey       | キー入力のキャンセル等                     | C-g          |
| helpKey       | ヘルプコマンド表示用                       | F1           |
| escapeKey     | このキーに続けて入力されたキーをエスケープ (KeySnail がハンドリングしない) | C-q          |
| macroStartKey | キーマクロの定義を開始                     | F3           |
| macroEndKey   | キーマクロの定義を終了 / 実行              | F4           |

これらのキーを変更したい場合は、設定ファイル内にて

<script src="http://gist.github.com/160289.js"></script>

のようにして下さい。

現在の特殊キーは key.listKeyBindings()　関数で見ることが出来ます。この関数はデフォルトの初期化ファイルにおいて f1 + b に割り当てられています。

これは、ステータスバーのアイコンを右クリックし「キーバインド一覧を表示」とするのと同じことです。

h2. コントロール / メタキーの変更

KeySnail がコントロールキー、メタキーと解釈するキーはデフォルトで次のようになっています。

* コントロールキー
** Ctrl
* メタキー
** Alt
** Command

この割り当てを変更したい場合は、初期化ファイル内で key.isControlKey(), key.isMetaKey() という関数を上書きして下さい。

これらの関数は元々次のような定義となっています。

<script src="http://gist.github.com/160290.js"></script>

例えば ControlKey に Caps Lock キーを使いたい場合は key.isControlKey() の定義を次のように変更すれば良いでしょう。

<script src="http://gist.github.com/160291.js"></script>

h1. 使い方

KeySnail がインストールされると、ブラウザのステータスバーに次のようなアイコンが現れます。



まずは、このアイコンの上で右クリックをしてみましょう。次のようなメニューが現れましたね。

では、ここから「キーバインド一覧を表示」を選んでクリックしてみましょう。新しいタブが開いて、次のようなページが表示されるはずです。

このページは、「ある状態」において「どんなキーの組み合わせ」が「どんな機能」へ割り当てられているか、ということを一覧表示しています。この組み合わせのことを「キーバインド」と言います。

「ある状態」をこの拡張機能では「モード」と呼びます。これは現在のところ三つ用意されており、それぞれ次のようなものとなっています。

h1. キーの割り当て方

どんなモードがあるのかを、前節ではご紹介しました。この節では、それぞれのモードにどうやって機能を割り当てていくか、ということについて学んでいきましょう。

まず初めに知っておかなければならないのは、「この拡張機能はカスタマイズの大半を設定ファイル経由で行う」ということです。他の親切な拡張機能のように分かりやすい GUI の設定画面は用意されていません。ゆえにカスタマイズの手順は、

# 設定ファイルをエディタで編集
# ステータスバーのメニューなどから、設定ファイルを再読み込みする

といったものとなります。

この設定ファイルはデフォルトでユーザのホームディレクトリ以下に作られます。 Windows ユーザの方は C:\Documents and Settings\ユーザ名 のようなプロファイルディレクトリ以下に作成されるはずです。

設定ファイルはインストール時に開いたウィザードですでに作成しているはずですが、もしウィザードをスキップしてしまったという方は、ステータスバーのメニューから「設定」を選び、「設定ファイルの作成 / 選択」からもう一度ウィザードをやり直してみて下さい。

それでは、まずは設定ファイルを覗いてみることにしましょう。お好みのエディタで前述のディレクトリから .keysnail.js もしくは _keysnail.js というファイルを開きます。

<pre>
<code>
// ==================== KeySnail configuration file ==================== //

// -------------------- キーシーケンスへの関数割り当て方法 -------------------- //
//
// 以下に示す関数群を使って, キーシーケンスを関数へと割り当てることができる.
//
// key.setGlobalKey(keys, func, ksDescription, ksNoRepeat);
// key.setEditKey(keys, func, ksDescription, ksNoRepeat);
// key.setViewKey(keys, func, ksDescription, ksNoRepeat);
// key.setCaretKey(keys, func, ksDescription, ksNoRepeat);
//
// 各引数の説明は次の通り.
</pre>
</code>

色々と説明が書かれていますが、この辺りはスキップしてしまいましょう。スクロールしていって 50 行目辺りに

